def hanoi(n, source, helper, target):
  """Функция находит решение для Ханойских башень
  состоящих из 3х стержней и n дисков.

  Задача смоделирована с помощью списков и чисел.
  Диски представлены числами, чем больше число тем
  больше диск. Стержни представлены как списки содержащие
  числа. Например данная конфигурация башень:

      ┌┐        ┌┐        ╔╗
     ▓▓▓▓       ││        ║║
    ▓▓▓▓▓▓      ││        ║║
   ▓▓▓▓▓▓▓▓     ││        ║║
  ▓▓▓▓▓▓▓▓▓▓    ││        ║║
  ────┴┴────────┴┴────────╨╨────
  ──SOURCE────HELPER────TARGET──

  моделируется как:

     source = [4, 3, 2, 1]
     helper = []
     target = []

  а следущая конфигурация:

      ┌┐        ┌┐        ╔╗
      ││        ││        ║║
      ││       ▓▓▓▓       ║║
      ││      ▓▓▓▓▓▓      ║║
      ││     ▓▓▓▓▓▓▓▓ ▓▓▓▓▓▓▓▓▓▓
  ────┴┴────────┴┴────────╨╨────
  ──SOURCE────HELPER────TARGET──

  моделируется вот-так:

     source = []
     helper = [3, 2, 1]
     target = [4]

  Входные данные:
   - n: число дисков в начальной башне (source)
   - source: начальная башня
   - helper: вспомогательная башня
   - target: конечная башня

  Пример работы:

    Ввод :
       n = 4
       source = [4, 3, 2, 1]
       helper = []
       target = []

    Результат:
       source = []
       helper = []
       target = [4, 3, 2, 1]
  """
  if n > 0:
    # Переносим n-1 дисков с начальной башни на вспомогательную,
    # с помощью рекурсивного вызова функции hanoi
    #     ┌┐        ┌┐        ╔╗
    #     ││        ││        ║║
    #     ││       ▓▓▓▓       ║║
    #     ││      ▓▓▓▓▓▓      ║║
    # ▓▓▓▓▓▓▓▓▓▓ ▓▓▓▓▓▓▓▓     ║║
    # ────┴┴────────┴┴────────╨╨────
    # ──SOURCE────HELPER────TARGET──
    #
    # Заметьте, как передаются параметры. Список source передается
    # как начальная башня, что ожидаемо. Однако список helper передается
    # как конечная башня, а target передается как вспомогательная башня.
    # Это происходит потому что, мы переносим n-1 дисков не в конченую башню,
    # а в вспомогательную, и роли списков меняются.
    hanoi(n - 1, source, target, helper)

    # Переносим самую большую шайбу на конечную башню,
    # путем переноса числа из одного списка в другой
    #     ┌┐        ┌┐        ┌┐
    #     ││        ││        ││
    #     ││       ▓▓▓▓       ││
    #     ││      ▓▓▓▓▓▓      ││
    #     ││     ▓▓▓▓▓▓▓▓ ▓▓▓▓▓▓▓▓▓▓
    # ────┴┴────────┴┴────────┴┴────
    # ──SOURCE────HELPER────TARGET──
    if source:
      target.append(source.pop())

    # Переносим башню со вспомогательной башни на конечную,
    # с помощью рекурсивного вызова функции hanoi
    #     ┌┐        ┌┐        ┌┐
    #     ││        ││       ▓▓▓▓
    #     ││        ││      ▓▓▓▓▓▓
    #     ││        ││     ▓▓▓▓▓▓▓▓
    #     ││        ││    ▓▓▓▓▓▓▓▓▓▓
    # ────┴┴────────┴┴────────┴┴────
    # ──SOURCE────HELPER────TARGET──
    #
    # Здесь роли списков тоже меняются, потому что мы переносим
    # башню НЕ из начального списка а из вспомогательного.
    hanoi(n - 1, helper, source, target)

source = [4,3,2,1]
helper = []
target = []

print(source, helper, target)

hanoi(len(source),source,helper,target)

print(source, helper, target)
